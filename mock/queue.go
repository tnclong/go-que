// Code generated by MockGen. DO NOT EDIT.
// Source: github.com/theplant/go-que (interfaces: Job,Queue,Mutex)

// Package mock is a generated GoMock package.
package mock

import (
	context "context"
	sql "database/sql"
	gomock "github.com/golang/mock/gomock"
	que "github.com/theplant/go-que"
	reflect "reflect"
	time "time"
)

// MockJob is a mock of Job interface
type MockJob struct {
	ctrl     *gomock.Controller
	recorder *MockJobMockRecorder
}

// MockJobMockRecorder is the mock recorder for MockJob
type MockJobMockRecorder struct {
	mock *MockJob
}

// NewMockJob creates a new mock instance
func NewMockJob(ctrl *gomock.Controller) *MockJob {
	mock := &MockJob{ctrl: ctrl}
	mock.recorder = &MockJobMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use
func (m *MockJob) EXPECT() *MockJobMockRecorder {
	return m.recorder
}

// Destroy mocks base method
func (m *MockJob) Destroy(arg0 context.Context) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Destroy", arg0)
	ret0, _ := ret[0].(error)
	return ret0
}

// Destroy indicates an expected call of Destroy
func (mr *MockJobMockRecorder) Destroy(arg0 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Destroy", reflect.TypeOf((*MockJob)(nil).Destroy), arg0)
}

// Done mocks base method
func (m *MockJob) Done(arg0 context.Context) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Done", arg0)
	ret0, _ := ret[0].(error)
	return ret0
}

// Done indicates an expected call of Done
func (mr *MockJobMockRecorder) Done(arg0 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Done", reflect.TypeOf((*MockJob)(nil).Done), arg0)
}

// Expire mocks base method
func (m *MockJob) Expire(arg0 context.Context, arg1 error) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Expire", arg0, arg1)
	ret0, _ := ret[0].(error)
	return ret0
}

// Expire indicates an expected call of Expire
func (mr *MockJobMockRecorder) Expire(arg0, arg1 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Expire", reflect.TypeOf((*MockJob)(nil).Expire), arg0, arg1)
}

// ID mocks base method
func (m *MockJob) ID() int64 {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ID")
	ret0, _ := ret[0].(int64)
	return ret0
}

// ID indicates an expected call of ID
func (mr *MockJobMockRecorder) ID() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ID", reflect.TypeOf((*MockJob)(nil).ID))
}

// In mocks base method
func (m *MockJob) In(arg0 *sql.Tx) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "In", arg0)
}

// In indicates an expected call of In
func (mr *MockJobMockRecorder) In(arg0 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "In", reflect.TypeOf((*MockJob)(nil).In), arg0)
}

// LastErrMsg mocks base method
func (m *MockJob) LastErrMsg() *string {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "LastErrMsg")
	ret0, _ := ret[0].(*string)
	return ret0
}

// LastErrMsg indicates an expected call of LastErrMsg
func (mr *MockJobMockRecorder) LastErrMsg() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "LastErrMsg", reflect.TypeOf((*MockJob)(nil).LastErrMsg))
}

// LastErrStack mocks base method
func (m *MockJob) LastErrStack() *string {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "LastErrStack")
	ret0, _ := ret[0].(*string)
	return ret0
}

// LastErrStack indicates an expected call of LastErrStack
func (mr *MockJobMockRecorder) LastErrStack() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "LastErrStack", reflect.TypeOf((*MockJob)(nil).LastErrStack))
}

// Plan mocks base method
func (m *MockJob) Plan() que.Plan {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Plan")
	ret0, _ := ret[0].(que.Plan)
	return ret0
}

// Plan indicates an expected call of Plan
func (mr *MockJobMockRecorder) Plan() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Plan", reflect.TypeOf((*MockJob)(nil).Plan))
}

// RetryAfter mocks base method
func (m *MockJob) RetryAfter(arg0 context.Context, arg1 time.Duration, arg2 error) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "RetryAfter", arg0, arg1, arg2)
	ret0, _ := ret[0].(error)
	return ret0
}

// RetryAfter indicates an expected call of RetryAfter
func (mr *MockJobMockRecorder) RetryAfter(arg0, arg1, arg2 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "RetryAfter", reflect.TypeOf((*MockJob)(nil).RetryAfter), arg0, arg1, arg2)
}

// RetryCount mocks base method
func (m *MockJob) RetryCount() int32 {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "RetryCount")
	ret0, _ := ret[0].(int32)
	return ret0
}

// RetryCount indicates an expected call of RetryCount
func (mr *MockJobMockRecorder) RetryCount() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "RetryCount", reflect.TypeOf((*MockJob)(nil).RetryCount))
}

// RetryInPlan mocks base method
func (m *MockJob) RetryInPlan(arg0 context.Context, arg1 error) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "RetryInPlan", arg0, arg1)
	ret0, _ := ret[0].(error)
	return ret0
}

// RetryInPlan indicates an expected call of RetryInPlan
func (mr *MockJobMockRecorder) RetryInPlan(arg0, arg1 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "RetryInPlan", reflect.TypeOf((*MockJob)(nil).RetryInPlan), arg0, arg1)
}

// MockQueue is a mock of Queue interface
type MockQueue struct {
	ctrl     *gomock.Controller
	recorder *MockQueueMockRecorder
}

// MockQueueMockRecorder is the mock recorder for MockQueue
type MockQueueMockRecorder struct {
	mock *MockQueue
}

// NewMockQueue creates a new mock instance
func NewMockQueue(ctrl *gomock.Controller) *MockQueue {
	mock := &MockQueue{ctrl: ctrl}
	mock.recorder = &MockQueueMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use
func (m *MockQueue) EXPECT() *MockQueueMockRecorder {
	return m.recorder
}

// Enqueue mocks base method
func (m *MockQueue) Enqueue(arg0 context.Context, arg1 *sql.Tx, arg2 ...que.Plan) ([]int64, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{arg0, arg1}
	for _, a := range arg2 {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "Enqueue", varargs...)
	ret0, _ := ret[0].([]int64)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Enqueue indicates an expected call of Enqueue
func (mr *MockQueueMockRecorder) Enqueue(arg0, arg1 interface{}, arg2 ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{arg0, arg1}, arg2...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Enqueue", reflect.TypeOf((*MockQueue)(nil).Enqueue), varargs...)
}

// Mutex mocks base method
func (m *MockQueue) Mutex() que.Mutex {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Mutex")
	ret0, _ := ret[0].(que.Mutex)
	return ret0
}

// Mutex indicates an expected call of Mutex
func (mr *MockQueueMockRecorder) Mutex() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Mutex", reflect.TypeOf((*MockQueue)(nil).Mutex))
}

// MockMutex is a mock of Mutex interface
type MockMutex struct {
	ctrl     *gomock.Controller
	recorder *MockMutexMockRecorder
}

// MockMutexMockRecorder is the mock recorder for MockMutex
type MockMutexMockRecorder struct {
	mock *MockMutex
}

// NewMockMutex creates a new mock instance
func NewMockMutex(ctrl *gomock.Controller) *MockMutex {
	mock := &MockMutex{ctrl: ctrl}
	mock.recorder = &MockMutexMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use
func (m *MockMutex) EXPECT() *MockMutexMockRecorder {
	return m.recorder
}

// Lock mocks base method
func (m *MockMutex) Lock(arg0 context.Context, arg1 string, arg2 int) ([]que.Job, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Lock", arg0, arg1, arg2)
	ret0, _ := ret[0].([]que.Job)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Lock indicates an expected call of Lock
func (mr *MockMutexMockRecorder) Lock(arg0, arg1, arg2 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Lock", reflect.TypeOf((*MockMutex)(nil).Lock), arg0, arg1, arg2)
}

// Unlock mocks base method
func (m *MockMutex) Unlock(arg0 context.Context, arg1 []int64) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Unlock", arg0, arg1)
	ret0, _ := ret[0].(error)
	return ret0
}

// Unlock indicates an expected call of Unlock
func (mr *MockMutexMockRecorder) Unlock(arg0, arg1 interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Unlock", reflect.TypeOf((*MockMutex)(nil).Unlock), arg0, arg1)
}
